public class CFG {
    // Control Flow Graphs(CFG)are a static analysis of software code used in software testing
    private Node startNode;
    private List<Node> nodes;
    private List<Edge> edges;
    private List<Node> exitNodes;

    public CFG() {
        //TODO: Implement the function
        this.startNode = null;
        this.nodes = new List<>();
        this.edges = new List<>();
        this.exitNodes = new List<>();
    }

    public CFG(Node[] nodes, Edge[] edges, Node sNode, Node[] exitNodes) {
        //TODO: Implement the function
        this.startNode = sNode;
        this.startNode = sNode;
        this.nodes = new List<>(nodes);
        this.edges = new List<>(edges);
        this.exitNodes = new List<>(exitNodes);
    }

    public CFG(CFG other) {
        //TODO: Implement the function
        if(other == null) {
            this.startNode = null;
            this.nodes = new List<>();
            this.edges = new List<>();
            this.exitNodes = new List<>();
        } else {
            this.startNode = (other.startNode != null) ? new Node(other.startNode) : null;
            this.nodes = new List<>(other.nodes);
            this.edges = new List<>(other.edges);
            this.exitNodes = new List<>(other.exitNodes);
        }
    }

    public void addNode(String annotation) {
        //TODO: Implement the function
        for (Object node : nodes.toArray()) {
            Node tempNode = (Node) node;
            if(tempNode.getAnnotation() == annotation) {
                return;
            }
        }
        nodes.append(new Node(annotation));
    }

    public void addNode(Node node) {
        //TODO: Implement the function
        if(node != null) {
            nodes.append(node);
        }
    }

    public void addEdge(String annotation, Node fromNode, Node toNode, int computationalTime) {
        //TODO: Implement the function
        if(computationalTime >= 0) {
            for (Object edge : edges.toArray()) {
                Edge tempEdge = (Edge) edge;
                if(tempEdge.getAnnotation() == annotation) {
                    return;
                }
            }
            // Create a new Edge with the given parameters and add it to the list of edges
            Edge edge = new Edge(annotation, toNode, computationalTime);
            fromNode.addEdge(toNode, annotation, computationalTime);
            edges.append(edge);
        }
    }

    public void addExitNode(Node node) {
        //TODO: Implement the function
        if(node != null) {
            if(nodes.contains(node) == false) {
                nodes.append(node);
            }
            if(exitNodes.contains(node) == false) {
                exitNodes.append(node);
            }
        }
    }

    public void addStartNode(Node node) {
        //TODO: Implement the function
        if(startNode == null) {
            startNode = node;
            if(nodes.contains(node) == false) {
                nodes.append(node);
            }
        }
    }

    public String toString() {
        // Do not alter!!!
        String res = "";
        for(Object node: nodes.toArray()) {
            res += node.toString();
        }
        return res;
    }

    public Node getNode(String annotation) {
        //TODO: Implement the function
        for (Object node : nodes.toArray()) {
            Node tempNode = (Node) node;
            if(tempNode.getAnnotation().equals(annotation)) {
                return tempNode;
            }
        }
        return null;
    }

    public int compTimeRequired(Path path) {
        //TODO: Implement the function
        if(path != null) {
            return path.computationalCostOfPath();
        }
        return -1;
    }

    public Path[] getSimplePaths() {
        //TODO: Implement the function
        /*
            - This function should return all the simple paths in the CFG as an array.
            - It can be assumed that the CFG will be a SESE CFG.
            - A SESE CFG can be described by the following properties:
                - Is a valid CFG.
                - Only has one exit node.
        */
        List<Path> paths = new List<>();
        List<Node> visitedNodes = new List<>();
        List<Edge> visitedEdges = new List<>();
        explorePaths(startNode, visitedNodes, visitedEdges, paths);
        // Conversions
        Object[] objects = paths.toArray();
        Path[] myPathsArray = new Path[objects.length];
        int counter = 0;
        for(Object path : objects) {
            Path tempPath = (Path) path;
            myPathsArray[counter] = tempPath;
            counter = counter + 1;
        }
        return myPathsArray;
    }
    // Helper Methods!!
    private void explorePaths(Node currentNode, List<Node> visitedNodes, List<Edge> visitedEdges, List<Path> paths) {
        // Add the current node to the visited nodes
        visitedNodes.append(currentNode);
        // Check if the current node is an exit node
        if (exitNodes.contains(currentNode)) {
            // Conversions Nodes
            Object[] objects = visitedNodes.toArray();
            Node[] myNodesArray = new Node[objects.length];
            int counter = 0;
            for(Object tNode : objects) {
                Node tempNode = (Node) tNode;
                myNodesArray[counter] = tempNode;
                counter = counter + 1;
            }
            // Conversions Edges
            objects = visitedEdges.toArray();
            Edge[] myEdgesArray = new Edge[objects.length];
            counter = 0;
            for(Object tEdge : objects) {
                Edge tempEdge = (Edge) tEdge;
                myEdgesArray[counter] = tempEdge;
                counter = counter + 1;
            }
            // Now Creating a new path using the visited nodes and edges
            Path path = new Path(startNode, currentNode, myNodesArray, myEdgesArray);
            paths.append(path);
        }
        // Explore the outgoing edges from the current node
        Edge[] edges = currentNode.getEdges();
        for (Edge edge : edges) {
            // Check if the edge has already been visited
            if (!visitedEdges.contains(edge)) {
                // append the edge to the visited edges
                visitedEdges.append(edge);
                // Recursively explore the next node in the path
                explorePaths(edge.getNext(), visitedNodes, visitedEdges, paths);
                // Remove the edge from the visited edges to backtrack
                visitedEdges.remove(edge);
            }
        }
        // Remove the current node from the visited nodes to backtrack
        visitedNodes.remove(currentNode);
    }
}
